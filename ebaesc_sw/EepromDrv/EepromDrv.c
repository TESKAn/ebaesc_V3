/***********************************************************************************************
* IMPORTANT. Read the following Freescale Software License Agreement (“Agreement”)             *
* completely. By usage of this software, you indicate that you accept the terms of this 	   *
* Agreement and you also acknowledge that you have the authority, on behalf of your company,   *
* to bind your company to such terms. You may then download or install the file.               *                                                 *
*                                                                                              *
* FREESCALE END-USER SOFTWARE LICENSE AGREEMENT                                                *
*                                                                                              *
* This is a license agreement between you (either as an individual or as an authorized         *
* representative acting on behalf of your employer) and Freescale Semiconductor,               *
* Inc. (“Freescale”). It concerns your rights to use the software provided to you in binary    *
* or source code form and any accompanying written materials (the “Software”). The Software    *
* may include any updates or error corrections or documentation relating to the Software       *
* provided to you by Freescale under this License. In consideration for Freescale allowing     *
* you to access the Software, you are agreeing to be bound by the terms of this Agreement.     *
* If you do not agree to all of the terms of this Agreement, do not download or install the    *
* Software. If you change your mind later, stop using the Software and delete all copies of    *
* the Software in your possession or control. Any copies of the Software that you have         *
* already distributed, where permitted, and do not destroy will continue to be governed by     *
* this Agreement. Your prior use will also continue to be governed by this Agreement.          *
*                                                                                              *
* 1. LICENSE GRANT. Freescale grants to you, free of charge, the non-exclusive,                *
* non-transferable, non-sublicensable right (1) to use the Software, (2) to reproduce the      *
* Software, (3) to prepare derivative works of the Software, and 4) to distribute the Software *
* and derivative works thereof in object (machine–readable) form as part of a programmable     *
* processing unit (e.g. a microprocessor, microcontroller, or digital signal processor)        *
* supplied directly or indirectly from Freescale (“Freescale System”)                          *
*                                                                                              *
* You must notify Freescale, in writing, any time you create a derivative of the Software.     *
* Freescale owns all derivatives created from the Software, and derivatives are licensed       *
* to you under the same terms as the Software under this Agreement. Upon request, you must     *
* provide Freescale the source code of any derivative of the Software. If you violate any of   *
* the terms or restrictions of this Agreement, Freescale may immediately terminate this        *
* Agreement, and require that you stop using and delete all copies of the Software and any     *
* derivative in your possession or control. Any license granted above only extends to          *
* Freescale’s intellectual property rights that would be necessarily infringed by the Software *
* as provided to you by Freescale and as used within the scope of the licenses granted. You    *
* must advise Freescale of any results obtained including any problems or suggested            *
* improvements thereof. Freescale retains the right to use such results and related            *
* information in any manner it deems appropriate.                                              *
*                                                                                              *
* 2. OTHER RESTRICTIONS. Subject to the license grant above, the following restrictions apply: *
*   a. Freescale reserves all rights not expressly granted herein.                             *
*   b. You may not rent, lease, sublicense, lend or encumber the Software, unless otherwise    *
*      expressly agreed to within this Agreement                                               *
*   c. You may not distribute, manufacture, have manufactured, sublicense or otherwise         *
*      reproduce the Software for purposes other than intended in this Agreement.              *
*   d. You may not remove or alter any proprietary legends, notices, or trademarks contained   *
*      in the Licensed Software,                                                               *
*   e. The terms and conditions of this Agreement will apply to any Software updates,          *
*      provided to you at Freescale’s discretion, that replace and/or supplement the           *
*      original software, unless such update contains a separate license.                      *
*   f. You may not translate, reverse engineer, decompile, or disassemble the Software         *
*      provided to you solely in object code format (machine readable) except to the extent    *
*      applicable law specifically prohibits such restriction. You will prohibit your          *
*      sublicensees from translating, reverse engineering, decompiling, or disassembling the   *
*      Software except to the extent applicable law specifically prohibits such restriction.   *
*                                                                                              *
* 3. OPEN SOURCE. Any open source software included in the Software licensed herein is not     *
* licensed under the terms of this Agreement, but is instead licensed under the terms of       *
* applicable open source license(s), such as the BSD License, Apache License or the Lesser     *
* GNU General Public License. Your use of such open source software is subject to the terms    *
* of each applicable license. You must agree to the terms of each such applicable license,     *
* or you should not use the open source software.                                              *
*                                                                                              *
* 4. COPYRIGHT. The Software is licensed to you, not sold. Freescale owns the Software, and    *
* United States copyright laws and international treaty provisions protect the Software.       *
* Therefore, you must treat the Software like any other copyrighted material (e.g. a book or   *
* musical recording). You may not use or copy the Software for any other purpose than what is  *
* described in this Agreement. Except as expressly provided herein, Freescale does not grant   *
* to you any express or implied rights under any Freescale or third party patents,             *
* copyrights, trademarks, or trade secrets. Additionally, you must reproduce and apply any     *
* copyright or other proprietary rights notices included on or embedded in the Software to     *
* any copies made thereof, in whole or in part, if any. You may not remove any copyright       *
* notices of Freescale incorporated in the Software.                                           *
*                                                                                              *
* 5. TERM AND TERMINATION. The term of this Agreement shall commence on the date of            *
* installation or download and shall continue perpetually, unless earlier terminated in        *
* accordance with this Agreement. Freescale has the right to terminate this Agreement without  *
* notice and require that you stop using and delete all copies of the Software in your         *
* possession or control if you violate any of the terms or restrictions of this Agreement.     *
* Freescale may terminate this Agreement should any of the Software become, or in Freescale's  *
* reasonable opinion is likely to become, the subject of a claim of intellectual infringement  *
* or trade secret misappropriation. Upon termination, you must cease use of and destroy, the   *
* Software and confirm compliance in writing to Freescale. Upon termination, the license       *
* granted pursuant to this Agreement immediately terminates and the provisions of Sections 4   *
* through 18 will survive any termination of this Agreement.                                   *
*                                                                                              *
* 6. SUPPORT. Freescale is NOT obligated to provide any support, upgrades or new               *
* of the Software. If you wish, you may contact Freescale and report problems and provide      *
* suggestions regarding the Software. Freescale has no obligation whatsoever to respond in     *
* any way to such a problem report or suggestion. Freescale may make changes to the Software   *
* at any time, without any obligation to notify or provide updated versions of the Software    *
* to you.                                                                                      *
*                                                                                              *
* 7. NO WARRANTY. TO THE MAXIMUM EXTENT PERMITTED BY LAW, FREESCALE EXPRESSLY                  *
* DISCLAIMS ANY WARRANTY FOR THE SOFTWARE. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY  *
* OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION, THE IMPLIED           *
* WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. YOU    *
* ASSUME THE ENTIRE RISK ARISING OUT OF THE USE OR PERFORMANCE OF THE SOFTWARE, OR ANY SYSTEMS *
* YOU DESIGN USING THE SOFTWARE (IF ANY). NOTHING IN THIS AGREEMENT MAY BE CONSTRUED AS A      *
* WARRANTY OR REPRESENTATION BY FREESCALE THAT THE SOFTWARE OR ANY DERIVATIVE WORK DEVELOPED   *
* WITH OR INCORPORATING THE SOFTWARE WILL BE FREE FROM INFRINGEMENT OF THE INTELLECTUAL        *
* PROPERTY RIGHTS OF THIRD PARTIES.                                                            *
*                                                                                              *
* 8. INDEMNITY. You agree to fully defend and indemnify Freescale from any and all             *
* claims, liabilities, and costs (including reasonable attorney’s fees) related to (1) your    *
* use (including your sublicensee’s use, if permitted) of the Software or (2) your violation   *
* of the terms and conditions of this Agreement.                                               *
*                                                                                              *
* 9. LIMITATION OF LIABILITY. IN NO EVENT WILL FREESCALE BE LIABLE, WHETHER IN                 *
* CONTRACT, TORT, OR OTHERWISE, FOR ANY INCIDENTAL, SPECIAL, INDIRECT, CONSEQUENTIAL OR        *
* PUNITIVE DAMAGES, INCLUDING, BUT NOT LIMITED TO, DAMAGES FOR ANY LOSS OF USE, LOSS OF TIME,  *
* INCONVENIENCE, COMMERCIAL LOSS, OR LOST PROFITS, SAVINGS, OR REVENUES TO THE FULL EXTENT     *
* SUCH MAY BE DISCLAIMED BY LAW EVEN IF INFORMED IN ADVANCE OF THE POSSIBILITY OF SUCH         *
* DAMAGES. FREESCALE’S LIABILITY WILL IN ANY EVENT AND UNDER ANY THEORY OF RECOVERY BE         *
* LIMITED TO THE TOTAL AMOUNT RECEIVED BY FREESCALE UNDER THIS AGREEMENT.                      *
*                                                                                              *
* 10. COMPLIANCE WITH LAWS; EXPORT RESTRICTIONS. You must not resell, re-export, or            *
* provide, directly or indirectly, the licensed software or direct product thereof, in any     *
* form without obtaining appropriate export or re-export licenses from the United States       *
* Government and from the country from which the export or re-export is to occur. An export    *
* occurs when products, technology, or software is transferred from one country to another by  *
* any means, including physical shipments, FTP file transfers, E-mails, faxes, remote server   *
* access, conversations, and the like. An export also occurs when technology or software is    *
* transferred to a foreign national in the United States, or foreign national of the country   *
* in which the business activity is taking place. A foreign national is any person who is      *
* neither a citizen nor permanent resident of the United States, or the country in which the   *
* business activity is taking place. Furthermore, if an export/import license, permit or other *
* government required authority (collectively referred to as “government authorization”) is    *
* required to transfer technology, software, hardware or other Freescale property to non-      *
* Freescale party(ies) and is not approved, then Freescale is not obligated to transfer the    *
* Software under this Agreement until such “government authorization” is granted..             *
*                                                                                              *
* 11. GOVERNMENT RIGHTS. The Licensed Software is a “Commercial Item” as defined in 48         *
* C.F.R. §2.101, consisting of “Commercial Computer Software” and “Commercial Computer         *
* Software Documentation,” as such terms are used in 48 C.F.R. § 12.212 or 48 C.F.R.           *
* §227.7202, as applicable and are only licensed to U.S. Government end users with the rights  *
* as are set forth herein..                                                                    *
*                                                                                              *
* 12. HIGH RISK ACTIVITIES. You acknowledge that the Software is not fault tolerant and        *
* is not designed, manufactured or intended by Freescale for incorporation into products       *
* intended for use or resale in on-line control equipment in hazardous, dangerous to life or   *
* potentially life-threatening environments requiring fail-safe performance, such as in the    *
* operation of nuclear facilities, aircraft navigation or communication systems, air traffic   *
* control, direct life support machines or weapons systems, in which the failure of products   *
* could lead directly to death, personal injury or severe physical or environmental damage     *
* (“High Risk Activities”). You specifically represent and warrant that you will not use the   *
* Software or any derivative work of the Software for High Risk Activities.                    *
*                                                                                              *
* 13. CHOICE OF LAW; VENUE; LIMITATIONS. You agree that the statutes and laws of the           *
* United States and the State of Texas, USA, without regard to conflicts of laws principles,   *
* will apply to all matters relating to this Agreement or the Software, and you agree that any *
* litigation will be subject to the exclusive jurisdiction of the state or federal courts in   *
* Texas, USA. You agree that regardless of any statute or law to the contrary, any claim or    *
* cause of action arising out of or related to this Agreement or the Software must be filed    *
* within one (1) year after such claim or cause of action arose or be forever barred.          *
*                                                                                              *
* 14. CONFIDENTIAL INFORMATION. You must treat the Software as confidential information        *
* and you agree to retain the Software in confidence perpetually, with respect to Software in  *
* source code form (human readable), or for a period of five (5) years from the date of        *
* termination of this Agreement, with respect to all other parts of the Software. During this  *
* period you may not disclose any part of the Software to anyone other than employees who have *
* a need to know of the Software and who have executed written agreements obligating them to   *
* protect such Licensed Software to at least the same degree of care as in this Agreement.     *
* You agree to use the same degree of care, but no less than a reasonable degree of care, with *
* the Software as you do with your own confidential information. You may disclose Software to  *
* the extent required by a court or under operation of law or order provided that you notify   *
* Freescale of such requirement prior to disclosure, which you only disclose information       *
* required, and that you allow Freescale the opportunity to object to such court or other      *
* legal body requiring such disclosure.                                                        *
*                                                                                              *
* 15. PRODUCT LABELING. You are not authorized to use any Freescale trademarks, brand          *
* names, or logos.                                                                             *
*                                                                                              *
* 16. ENTIRE AGREEMENT. This Agreement constitutes the entire agreement between you and        *
* Freescale regarding the subject matter of this Agreement, and supersedes all prior           *
* communications, negotiations, understandings, agreements or representations, either written  *
* or oral, if any. This Agreement may only be amended in written form, executed by you and     *
* Freescale.                                                                                   *
*                                                                                              *
* 17. SEVERABILITY. If any provision of this Agreement is held for any reason to be            *
* invalid or unenforceable, then the remaining provisions of this Agreement will be unimpaired *
* and, unless a modification or replacement of the invalid or unenforceable provision is       *
* further held to deprive you or Freescale of a material benefit, in which case the Agreement  *
* will immediately terminate, the invalid or unenforceable provision will be replaced with a   *
* provision that is valid and enforceable and that comes closest to the intention underlying   *
* the invalid or unenforceable provision.                                                      *
*                                                                                              *
* 18. NO WAIVER. The waiver by Freescale of any breach of any provision of this                *
* Agreement will not operate or be construed as a waiver of any other or a subsequent breach   *
* of the same or a different provision.                                                        *
***********************************************************************************************/

/***************************************************************************//*!
*
* @file      EepromDrv.c
*
* @author    B36524
* 
* @version   1.0
* 
* @date      Nov-13-2014
* 
* @brief     EEPROM Driver Library for 56F847xx and 56F827xx DSC family.
* 			 -This file contains code of EEPROM Driver Library functions.
*  			 -All changes in settings should be done in EepromDrv_cfg.h file. 
* 			 -All user available functions are listed in "Function prototypes"
* 			 section of EepromDrv.h file. For more detailed description of all 
* 			 functions see "Function definitions" section in this file. 
*
******************************************************************************/

// EEPROM Driver Library header file
#include "EepromDrv.h"


/******************************************************************************
 * Global variables 
 *****************************************************************************/
#if (!EEPROM_EMULATION)
UWord16 uw16EEESize;			// original EEESize
UWord16 uw16EEBackUpFlashSize;  // original backup flash size 
#endif

/*****************************************************************************
 * 	Function definitions 
 *****************************************************************************/

/*****************************************************************************
* UWord16 CrcCalculation(void)
* 
* @brief	Cyclic redundancy check of a string of data in bytes. Return the 
* 			crc code.
* 
* @param    pbData - byte pointer to a string of data that needs CRC
*           w16Cnt - length of the data string in unit of bytes
* 
* @return 	CRC code
* 			
*****************************************************************************/
UWord16 Crc_Calculation(UWord8 *pbData, UWord16 w16Cnt)
{	
	UD_CRC_CRCH = 0x0000; // trigger CRC calculation
	UD_CRC_CRCL = 0x0000; // Seed = 0x0000
	while(w16Cnt--)
	{
		UD_CRC_CRCL = *pbData;
		pbData++;
	}
	return ((UD_CRC_CRCH<<8)|UD_CRC_CRCL);
}

#if (EEPROM_EMULATION)

/*****************************************************************************
* UWord8 EepromDrv_Write(void)
* 
* @brief	EEPROM writing emulation, which is actually incremental writing 
* 			of new entry. The function writes FLASHDRV_IWRT_ENTRY structure 
* 			to first empty space in flash. The crc code of data string in 
* 			the FLASHDRV_IWRT_ENTRY structure is calculated and also written 
* 			into Flash as part of the entry.
* 
* @param    N/A
* 
* @return 	EEPROM_FLASHDRV_SUCCESS - Function ended successfully
* 			EEPROM_FLASHDRV_FAIL - Status bit (FTFL_FSTAT[MGSTAT0]) was set 
* 							(verify operation failed)
* 			EEPROM_FLASHDRV_ACCESS_ERROR - Writing failed/invalid parameters (see
* 								   MC56F827xx/MC56F847xx reference manual)
* 			EEPROM_FLASHDRV_PROT_VIOLATION - Protection violation
* 
*****************************************************************************/
UWord8 EepromDrv_Write(void)
{
	Word16 w16Tmp;
	UWord8*  pbData;
	UWord8	ucResult;
	w16Tmp = sizeof(FLASHDRV_IWRT_DATA_T); // in unit of bytes
	w16Tmp -= 2;	// get the length of data string in unit of bytes 
	pbData = (UWord8*)FLASHDRV_IWRT_DATA;
	
	FLASHDRV_IWRT_DATA->dwCrcSum = Crc_Calculation(pbData, w16Tmp); // get the crc code
	ucResult = FlashDrv_IncWrite();	// write the data string and crc code into flash
	
	return ucResult;
}

/*****************************************************************************
* UWord8 EepromDrv_Read(UWord16 uw16EntryAge)
* 
* @brief	This function initializes the FLASHDRV_IWRT_DATA structure with
* 			data from older entry. wEntryAge parameter defines which entry will
* 			be used. Using wEntryAge equal to zero returns newest entry. 
* 			wEntryAge must be lower than FLASHDRV_IWRT_INFO.wEntryCnt. Input 
* 			parameters are checked.
*
* @param    wEntryAge - Determines which entry to return
* 
* @return 	EEPROM_FLASHDRV_SUCCESS - Valid data are read out to FLASHDRV_IWRT_DATA
* 			EEPROM_FLASHDRV_ACCESS_ERROR - Invalid parameters
* 			EEPROM_CRC_ERROR    - Data are read out to FLASHDRV_IWRT_DATA, but
* 			                      the crc checksum is wrong
* 
*****************************************************************************/
UWord8 EepromDrv_Read(UWord16 uw16EntryAge)
{
	Word16 w16Tmp,w16Crc;
	UWord8*  pbData;
	UWord8	ucResult;
	ucResult = FlashDrv_GetEntry(uw16EntryAge); // read the latest entry 
	
	if(ucResult == FLASHDRV_ACCESS_ERROR)
	{
		return EEPROM_FLASHDRV_ACCESS_ERROR;
	}
	else
	{
		w16Tmp = sizeof(FLASHDRV_IWRT_DATA_T); // in unit of bytes
		w16Tmp -= 2;	// get the length of data string in unit of bytes 
		pbData = (UWord8*)FLASHDRV_IWRT_DATA;
		
		// get the crc code of data string and the previously stored crc code
		Crc_Calculation(pbData, w16Tmp); 
		UD_CRC_CRCL = (FLASHDRV_IWRT_DATA->dwCrcSum >> 8) & 0x00ff;
		UD_CRC_CRCL = (FLASHDRV_IWRT_DATA->dwCrcSum) & 0x00ff;
		w16Crc = ((UD_CRC_CRCH<<8)|UD_CRC_CRCL);
		
		// crc check should be zero
		if(w16Crc == 0)
		{
			return EEPROM_FLASHDRV_SUCCESS;
		}
		else
		{
			return EEPROM_CRC_ERROR;
		}
	}
}

#else



/***************************************************************************//*!
*
* @brief  Read the IFR of Data Flash to get the size of EEPROM and the partition
* 		  information
*
* @param  N/A
*
* @return EEPROM_FLASHDRV_SUCCESS - Successfully get the EEPROM information 
*	 	  EEPROM_FLASHDRV_FAIL - Status bit (FTFL_FSTAT[MGSTAT0]) is set
*	 	  						(normally this bit shouldn't be set in this command) 					
* 	 	  EEPROM_FLASHDRV_ACCESS_ERROR  - Writing failed/invalid parameters 
* 	 	  						(see MC56F847xx reference manual)
* 	 	  EEPROM_FLASHDRV_PROT_VIOLATION - Protection violation
*								(normally this bit shouldn't be set in this command) 
* @remarks 	The function reads from address 0xFC & 0xFD of Data Flash IFR to 
*           get "EEPROM data set size" and store it to "uw16EEESize".
* 			It also gets "FlexNVM partition code" and store it to 
* 			"uw16EEBackUpFlashSize"
*
****************************************************************************/
asm UWord32 GetEepromInfo(void)
{
	// push r0
	adda		#2,sp
	move.l		r0,X:(sp)
	
	// check CCIF bit of the flash status register
CCIF_CHECK:
	move.l		#FTFL_FSTAT_E,r0
	moveu.bp	X:(r0),A	
	brclr		#0x80,A1,CCIF_CHECK
	
	// clear RDCOLERR, ACCERR, FPVIOL flag
	move.w		#0x70,A1
	move.bp		A1,X:(r0)
	
	// configure command registers to read out IFR 
	move.l		#FTFL_FCCOB0_E,R0
	move.w		#FTFL_READ_RESOURCE,A1
	move.bp		A1,X:(r0)
	move.l		#FTFL_FCCOB1_E,R0
	move.w		#0x80,A1
	move.bp		A1,X:(r0)
	move.l		#FTFL_FCCOB2_E,R0
	move.w		#0x00,A1
	move.bp		A1,X:(r0)
	move.l		#FTFL_FCCOB3_E,R0
	move.w		#0xFC,A1
	move.bp		A1,X:(r0)
	// clear CCIF to start the commands
	move.l		#FTFL_FSTAT_E,r0
	move.w		#0x80,A1
	move.bp		A1,X:(r0)	

	
	// check CCIF bit of the flash status register
CCIF_CHECK_1:
	moveu.bp	X:(r0),A	
	brclr		#0x80,A1,CCIF_CHECK_1
	
	// store the results
	move.l		#FTFL_FCCOB6_E,r0
	move.bp		x:(r0),x:uw16EEESize
	move.l		#FTFL_FCCOB7_E,r0
	move.bp		x:(r0),x:uw16EEBackUpFlashSize
	
	// pop r0
	move.l		X:(sp)-,r0
	
	// get the error information
	bftstl		#EEPROM_ACCERR_MASK|EEPROM_PROT_VIOL_MASK|EEPROM_MGSTAT0_MASK,A1
	bcs			OPERATION_SUCCESS
	brset		#EEPROM_ACCERR_MASK,A1,ACCERR_ERROR	
	brset		#EEPROM_PROT_VIOL_MASK,A1,PROT_VIOLATION	
	move.w		#EEPROM_FLASHDRV_FAIL,A0
	rts
OPERATION_SUCCESS:
	clr.w		A0
	rts
ACCERR_ERROR:
	move.w		#EEPROM_FLASHDRV_ACCESS_ERROR,A0
	rts
PROT_VIOLATION:
	move.w		#EEPROM_FLASHDRV_PROT_VIOLATION,A0
	rts
}

/***************************************************************************//*!
*
* @brief  Configure the EEPROM. Set the size of EEPROM and the backup 
* 		  Data Flash size using the defined code
*
* @param  EEEDataSize: The size of EEPROM desired. See @remarks.
*         EEBackUpFlashSize: The size of FlexNVM that is used as the backup of EEPROM
*         See @remarks.
*
* @return EEPROM_FLASHDRV_SUCCESS - Successfully get the EEPROM information 
*	 	  EEPROM_FLASHDRV_FAIL - Status bit (FTFL_FSTAT[MGSTAT0]) is set
*	 	  						(any errors have been encountered during the verify operation) 					
* 	 	  EEPROM_FLASHDRV_ACCESS_ERROR  - Writing failed/invalid parameters 
* 	 	  						(see MC56F847xx reference manual)
* 	 	  				Following actions trigger this error:
* 	 	  				1. Using reserved values for "EEEDataSize" and "EEBackUpFlashSize" 	
* 	 	  				2. "EEBackUpFlashSize" equals to "DEPART_0K", while 
* 	 	  				   "EEEDataSize" equals to value that allocates FlexRAM for EEPROM
* 	 	  				3. "EEEDataSize" equals to "EEESIZE_0B", while "EEBackUpFlashSize"
* 	 	  				   equals to value that allocates space for EEPROM backup
* 	 	  				4. Data Flash is already partitioned  
* 	 	  EEPROM_FLASHDRV_PROT_VIOLATION - Protection violation
*								(normally this bit shouldn't be set in this command) 
*		                        
* @remarks 	This function sets up the size of EEPROM and the backup Flash size.
* 			The available values for EEEDataSize are:
* 			EEESIZE_0B
* 			EEESIZE_32B	 (32 Bytes of EEPROM)
* 			EEESIZE_64B  (64 Bytes of EEPROM)
* 			EEESIZE_128B
* 			EEESIZE_256B
* 			EEESIZE_512B
* 			EEESIZE_1024B
* 			EEESIZE_2048B 
* 			The available values for EEBackUpFlashSize are:
* 			DEPART_0K
* 			DEPART_8K (8KBytes of FlexNVM is used as backup for EEPROM)
* 			DEPART_16K
* 			DEPART_32K
* 			DEPART_24K
* e.g. DEFlashPartition(EEESIZE_512B,DEPART_32K); it means the EEPROM has a volume of 512 bytes and 32K flash as backup
****************************************************************************/
asm UWord32 DEFlashPartition(UWord8 EEEDataSize, UWord8 EEBackUpFlashSize)
{
	// y0 is EEEDataSize, y1 is EEBackUpFlashSize
	
	// push r0
	adda		#2,sp
	move.l		r0,X:(sp)
	
	// setup command registers
	move.l		#FTFL_FCCOB0_E,R0			// command
	move.w		#FTFL_PROGRAM_PARTITION,A1
	move.bp		a1,X:(r0)
	
	move.l		#FTFL_FCCOB4_E,R0			// EEPROM data size
	move.bp		y0,X:(r0)
	
	move.l		#FTFL_FCCOB5_E,R0			// partition code
	move.bp		y1,X:(r0)
	
	// wait until FTFL is free
CCIF_CHECK:
	move.l		#FTFL_FSTAT_E,r0
	moveu.bp	X:(r0),A	
	brclr		#0x80,A1,CCIF_CHECK
	
	// clear RDCOLERR, ACCERR, FPVIOL flag
	move.w		#0x70,A1
	move.bp		A1,X:(r0)
	
	// disable interrupts
	bfset		#0x0300,SR
	nop
	nop
	nop
	
	// clear CCIF to execute the command
	move.w		#0x80,A1
	move.bp		a1,x:(r0)	

	// check CCIF bit of the flash status register
CCIF_CHECK_1:
	moveu.bp	X:(r0),A	
	brclr		#0x80,A1,CCIF_CHECK_1
	
	// check EEERDY bit of flash configuration register
EEERDY_CHECK:
	move.l      #FTFL_FCNFG_E,r0
	moveu.bp	X:(r0),A
	brclr		#0x01,A1,EEERDY_CHECK
	
	move.l		#FTFL_FSTAT_E,r0
	moveu.bp	X:(r0),A	// get error state
	
	// enable interrupts
	bfclr		#0x0300,SR
	
	// pop r0
	move.l		X:(sp)-,r0
	
	// get the error information
	bftstl		#EEPROM_ACCERR_MASK|EEPROM_PROT_VIOL_MASK|EEPROM_MGSTAT0_MASK,A1
	bcs			OPERATION_SUCCESS
	brset		#EEPROM_ACCERR_MASK,A1,ACCERR_ERROR	
	brset		#EEPROM_PROT_VIOL_MASK,A1,PROT_VIOLATION	
	move.w		#EEPROM_FLASHDRV_FAIL,A0
	rts
OPERATION_SUCCESS:
	clr.w		A0
	rts
ACCERR_ERROR:
	move.w		#EEPROM_FLASHDRV_ACCESS_ERROR,A0
	rts
PROT_VIOLATION:
	move.w		#EEPROM_FLASHDRV_PROT_VIOLATION,A0
	rts
}

/***************************************************************************//*!
*
* @brief  Enable EEPROM function
* 		  
*
* @param  N/A
*
* @return EEPROM_FLASHDRV_SUCCESS - Successfully enable FlexRAM as interface to 
*                                   EEPROM 
*	 	  EEPROM_FLASHDRV_FAIL - Status bit (FTFL_FSTAT[MGSTAT0]) is set
*	 	  						(normally this bit shouldn't be set in this command) 					
* 	 	  EEPROM_FLASHDRV_ACCESS_ERROR  - Writing failed/invalid parameters 
* 	 	  						(see MC56F847xx reference manual)
* 	 	  EEPROM_FLASHDRV_PROT_VIOLATION - Protection violation
*								(normally this bit shouldn't be set in this command) 
*		
* @remarks 	Enable EEPROM function, FlexRAM serves as interface to EEPROM
*
****************************************************************************/
asm UWord32 SetEEEEnable(void)
{
	// push r0
	adda		#2,sp
	move.l		r0,X:(sp)
	
	// setup command registers
	move.l		#FTFL_FCCOB0_E,R0			// command
	move.w		#FTFL_SET_EERAM,A1
	move.bp		a1,X:(r0)
	
	move.l		#FTFL_FCCOB1_E,R0			// make FlexRAM available for EEPROM
	move.w		#0x00,A1
	move.bp		A1,X:(r0)
	
	// wait until FTFL is free
CCIF_CHECK:
	move.l		#FTFL_FSTAT_E,r0
	moveu.bp	X:(r0),A	
	brclr		#0x80,A1,CCIF_CHECK
	
	// clear RDCOLERR, ACCERR, FPVIOL flag
	move.w		#0x70,A1
	move.bp		A1,X:(r0)
	
	// clear CCIF to execute the command
	move.w		#0x80,A1
	move.bp		a1,x:(r0)	

	// check CCIF bit of the flash status register
CCIF_CHECK_1:
	moveu.bp	X:(r0),A	
	brclr		#0x80,A1,CCIF_CHECK_1
	
	// pop r0
	move.l		X:(sp)-,r0

	// get the error information
	bftstl		#EEPROM_ACCERR_MASK|EEPROM_PROT_VIOL_MASK|EEPROM_MGSTAT0_MASK,A1
	bcs			OPERATION_SUCCESS
	brset		#EEPROM_ACCERR_MASK,A1,ACCERR_ERROR	
	brset		#EEPROM_PROT_VIOL_MASK,A1,PROT_VIOLATION	
	move.w		#EEPROM_FLASHDRV_FAIL,A0
	rts
OPERATION_SUCCESS:
	clr.w		A0
	rts
ACCERR_ERROR:
	move.w		#EEPROM_FLASHDRV_ACCESS_ERROR,A0
	rts
PROT_VIOLATION:
	move.w		#EEPROM_FLASHDRV_PROT_VIOLATION,A0
	rts
}

/***************************************************************************//*!
*
* @brief  Disable EEPROM function
* 		  
*
* @param  N/A
*
* @return EEPROM_FLASHDRV_SUCCESS - Successfully set FlexRAM as regular RAM 
*	 	  EEPROM_FLASHDRV_FAIL - Status bit (FTFL_FSTAT[MGSTAT0]) is set
*	 	  						(normally this bit shouldn't be set in this command) 					
* 	 	  EEPROM_FLASHDRV_ACCESS_ERROR  - Writing failed/invalid parameters 
* 	 	  						(see MC56F847xx reference manual)
* 	 	  EEPROM_FLASHDRV_PROT_VIOLATION - Protection violation
*								(normally this bit shouldn't be set in this command) 
*		
* @remarks 	Enable EEPROM function, FlexRAM serves as regular RAM
*
****************************************************************************/
asm UWord32 SetEEEDisable(void)
{
	// push r0
	adda		#2,sp
	move.l		r0,X:(sp)
	
	// setup command registers
	move.l		#FTFL_FCCOB0_E,R0			// command
	move.w		#FTFL_SET_EERAM,A1
	move.bp		a1,X:(r0)
	
	move.l		#FTFL_FCCOB1_E,R0			// make FlexRAM regular RAM
	move.w		#0xFF,A1
	move.bp		A1,X:(r0)
	
	// wait until FTFL is free
CCIF_CHECK:
	move.l		#FTFL_FSTAT_E,r0
	moveu.bp	X:(r0),A	
	brclr		#0x80,A1,CCIF_CHECK
	
	// clear RDCOLERR, ACCERR, FPVIOL flag
	move.w		#0x70,A1
	move.bp		A1,X:(r0)
	
	// clear CCIF to execute the command
	move.w		#0x80,A1
	move.bp		a1,x:(r0)	

	// check CCIF bit of the flash status register
CCIF_CHECK_1:
	moveu.bp	X:(r0),A	
	brclr		#0x80,A1,CCIF_CHECK_1
	
	// pop r0
	move.l		X:(sp)-,r0

	// get the error information
	bftstl		#EEPROM_ACCERR_MASK|EEPROM_PROT_VIOL_MASK|EEPROM_MGSTAT0_MASK,A1
	bcs			OPERATION_SUCCESS
	brset		#EEPROM_ACCERR_MASK,A1,ACCERR_ERROR	
	brset		#EEPROM_PROT_VIOL_MASK,A1,PROT_VIOLATION	
	move.w		#EEPROM_FLASHDRV_FAIL,A0
	rts
OPERATION_SUCCESS:
	clr.w		A0
	rts
ACCERR_ERROR:
	move.w		#EEPROM_FLASHDRV_ACCESS_ERROR,A0
	rts
PROT_VIOLATION:
	move.w		#EEPROM_FLASHDRV_PROT_VIOLATION,A0
	rts
}

/***************************************************************************//*!
*
* @brief  Write a byte into EEPROM
* 		  
*
* @param  byteAddr: the byte address of EEPROM, this is the place where the data
* 					is written into
* 		  data:     the byte data 
*
* @return N/A
*		
* @remarks 	Write a byte into EEPROM. Beware that the base address starts at 0x3c000
*
****************************************************************************/
asm void EepromWriteByte(UWord32 byteAddr,UWord8 data)
{
	// A is address,Y0 is data
	
	// push b,r0
	adda		#2,sp
	move.l		b2,x:(sp)+
	move.l		b10,x:(sp)+
	move.l		r0,X:(sp)
	tfr			a,b
	
	// wait for CCIF bit becoming 1
	move.l		#FTFL_FSTAT_E,R0			
CCIF_CHECK:
	move.bp		X:(r0),A
	brclr		#0x80,A1,CCIF_CHECK
	
	// wait for EEERDY bit becoming 1
	move.l		#FTFL_FCNFG_E,R0			
EEERDY_CHECK:
	move.bp		X:(r0),A
	brclr		#0x01,A1,EEERDY_CHECK
	
	// write the data into eeprom
	move.l		b10,r0
	move.bp		y0,x:(r0)
	
	// pop b,r0
	move.l		x:(sp)-,r0
	move.l		x:(sp)-,b
	move.l		x:(sp)-,b2
	
	rts
}

/***************************************************************************//*!
*
* @brief  Write a string of bytes into EEPROM
* 		  
*
* @param  byteAddr: the byte address of EEPROM, this is the start place where 
* 					the data string is written into
* 		  data:     the byte data pointer
* 		  length:   the length of the string in unit of Byte
*
* @return N/A
*		
* @remarks 	Write a string of bytes into EEPROM. Beware that the base address 
*           starts at 0x3c000
*
****************************************************************************/
asm void EepromWriteByteString(UWord32 byteAddr,UWord8* data, UWord16 length)
{
	// A is address,R2 is data pointer,Y0 is the length of the string
	
	// push b,r0
	adda		#2,sp
	move.l		b2,x:(sp)+
	move.l		b10,x:(sp)+
	move.l		r0,X:(sp)
	tfr			a,b

WRITE_BYTE:
	// wait for CCIF bit becoming 1
	move.l		#FTFL_FSTAT_E,R0			
CCIF_CHECK:
	move.bp		X:(r0),A
	brclr		#0x80,A1,CCIF_CHECK
	
	// wait for EEERDY bit becoming 1
	move.l		#FTFL_FCNFG_E,R0			
EEERDY_CHECK:
	move.bp		X:(r0),A
	brclr		#0x01,A1,EEERDY_CHECK
	
	// write the data into EEPROM
	move.l		b10,r0		// r0 contains destination address of EEPROM
	move.bp		x:(r2),a	// r2 contains the source address of the data
	move.bp		a1,x:(r0)
	adda		#1,r2		// source address ++
	inc.l		b			// destination address ++
	dec.w		y0			// length--
	bne			WRITE_BYTE
	
	// pop b,r0
	move.l		x:(sp)-,r0
	move.l		x:(sp)-,b
	move.l		x:(sp)-,b2
	
	rts
}

/***************************************************************************//*!
*
* @brief  Read a string of bytes from EEPROM
* 		  
*
* @param  byteAddr: the byte address of EEPROM, this is the start place where 
* 					the data string is read 
* 		  data:     the byte data pointer
* 		  length:   the length of the string in unit of Byte
*
* @return N/A
*		
* @remarks 	Read a string of bytes from EEPROM. Beware that the base address 
*           starts at 0x3c000
*
****************************************************************************/
asm void EepromReadByteString(UWord32 byteAddr,UWord8* data, UWord16 length)
{
	// A is address,R2 is data pointer,Y0 is the length of the string
	
	// push b,r0
	adda		#2,sp
	move.l		b2,x:(sp)+
	move.l		b10,x:(sp)+
	move.l		r0,X:(sp)
	tfr			a,b

READ_BYTE:
	// wait for CCIF bit becoming 1
	move.l		#FTFL_FSTAT_E,R0			
CCIF_CHECK:
	move.bp		X:(r0),A
	brclr		#0x80,A1,CCIF_CHECK
	
	// wait for EEERDY bit becoming 1
	move.l		#FTFL_FCNFG_E,R0			
EEERDY_CHECK:
	move.bp		X:(r0),A
	brclr		#0x01,A1,EEERDY_CHECK
	
	// read the data from EEPROM
	move.l		b10,r0		// r0 contains source address of EEPROM
	move.bp		x:(r0),a	// r2 contains the destination address of the data
	move.bp		a1,x:(r2)
	adda		#1,r2		// source address ++
	inc.l		b			// destination address ++
	dec.w		y0			// length--
	bne			READ_BYTE
	
	// pop b,r0
	move.l		x:(sp)-,r0
	move.l		x:(sp)-,b
	move.l		x:(sp)-,b2
	
	rts
}


/***************************************************************************//*!
*
* @brief  Read a byte from EEPROM
* 		  
*
* @param  byteAddr: the byte address of EEPROM, this is the place where the data is
*                   fetched from
* 		  data:     a byte pointer 
*
* @return N/A
*		
* @remarks 	Read a byte from EEPROM. Beware that the base address starts at 0x3c000
*
****************************************************************************/
asm void EepromReadByte(UWord32 byteAddr,UWord8 *data)
{
	// A is address,R2 is data pointer
	
	// push b,r0
	adda		#2,sp
	move.l		b2,x:(sp)+
	move.l		b10,x:(sp)+
	move.l		r0,X:(sp)
	tfr			a,b
	
	// wait for CCIF bit becoming 1
	move.l		#FTFL_FSTAT_E,R0			
CCIF_CHECK:
	move.bp		X:(r0),A
	brclr		#0x80,A1,CCIF_CHECK
	
	// wait for EEERDY bit becoming 1
	move.l		#FTFL_FCNFG_E,R0			
EEERDY_CHECK:
	move.bp		X:(r0),A
	brclr		#0x01,A1,EEERDY_CHECK
	
	// read the data from eeprom
	move.l		b10,r0
	move.bp		x:(r0),A
	move.bp		A1,x:(r2)
	
	// pop b,r0
	move.l		x:(sp)-,r0
	move.l		x:(sp)-,b
	move.l		x:(sp)-,b2
	
	rts
}

/***************************************************************************//*!
*
* @brief  Write a word into EEPROM
* 		  
*
* @param  wordAddr: the word address of EEPROM, this is the place where the data
* 					is written into
* 		  data:     the word data 
*
* @return   N/A
*		
* @remarks 	Write a word into EEPROM. Beware that the base address starts at 0x1e000
*
****************************************************************************/
asm void EepromWriteWord(UWord32 wordAddr,UWord16 data)
{
	// A is address,Y0 is data
	
	// push b,r0
	adda		#2,sp
	move.l		b2,x:(sp)+
	move.l		b10,x:(sp)+
	move.l		r0,X:(sp)
	tfr			a,b
	
	// wait for CCIF bit becoming 1
	move.l		#FTFL_FSTAT_E,R0			
CCIF_CHECK:
	move.bp		X:(r0),A
	brclr		#0x80,A1,CCIF_CHECK
	
	// wait for EEERDY bit becoming 1
	move.l		#FTFL_FCNFG_E,R0			
EEERDY_CHECK:
	move.bp		X:(r0),A
	brclr		#0x01,A1,EEERDY_CHECK
	
	// write the data into eeprom
	move.l		b10,r0
	move.w		y0,x:(r0)
	
	// pop b,r0
	move.l		x:(sp)-,r0
	move.l		x:(sp)-,b
	move.l		x:(sp)-,b2
	
	rts
}

/***************************************************************************//*!
*
* @brief  Write a string of words into EEPROM
* 		  
*
* @param  wordAddr: the word address of EEPROM, this is the start place where 
* 					the data string is written into
* 		  data:     the word data pointer
* 		  length:   the length of the string in unit of Word
*
* @return N/A
*		
* @remarks 	Write a string of words into EEPROM. Beware that the base address 
*           starts at 0x1e000
*
****************************************************************************/
asm void EepromWriteWordString(UWord32 wordAddr,UWord16* data, UWord16 length)
{
	// A is address,R2 is data pointer,Y0 is the length of the string
	
	// push b,r0
	adda		#2,sp
	move.l		b2,x:(sp)+
	move.l		b10,x:(sp)+
	move.l		r0,X:(sp)
	tfr			a,b

WRITE_WORD:
	// wait for CCIF bit becoming 1
	move.l		#FTFL_FSTAT_E,R0			
CCIF_CHECK:
	move.bp		X:(r0),A
	brclr		#0x80,A1,CCIF_CHECK
	
	// wait for EEERDY bit becoming 1
	move.l		#FTFL_FCNFG_E,R0			
EEERDY_CHECK:
	move.bp		X:(r0),A
	brclr		#0x01,A1,EEERDY_CHECK
	
	// write the data into EEPROM
	move.l		b10,r0		// r0 contains destination address of EEPROM
	move.w		x:(r2),a	// r2 contains the source address of the data
	move.w		a1,x:(r0)
	adda		#1,r2		// source address ++
	inc.l		b			// destination address ++
	dec.w		y0			// length--
	bne			WRITE_WORD
	
	// pop b,r0
	move.l		x:(sp)-,r0
	move.l		x:(sp)-,b
	move.l		x:(sp)-,b2
	
	rts
}

/***************************************************************************//*!
*
* @brief  Read a string of words from EEPROM
* 		  
*
* @param  wordAddr: the word address of EEPROM, this is the start place where 
* 					the data string is read 
* 		  data:     the word data pointer
* 		  length:   the length of the string in unit of Word
*
* @return N/A
*		
* @remarks 	Read a string of words from EEPROM. Beware that the base address 
*           starts at 0x1e000
*
****************************************************************************/
asm void EepromReadWordString(UWord32 wordAddr,UWord16* data, UWord16 length)
{
	// A is address,R2 is data pointer,Y0 is the length of the string
	
	// push b,r0
	adda		#2,sp
	move.l		b2,x:(sp)+
	move.l		b10,x:(sp)+
	move.l		r0,X:(sp)
	tfr			a,b

READ_WORD:
	// wait for CCIF bit becoming 1
	move.l		#FTFL_FSTAT_E,R0			
CCIF_CHECK:
	move.bp		X:(r0),A
	brclr		#0x80,A1,CCIF_CHECK
	
	// wait for EEERDY bit becoming 1
	move.l		#FTFL_FCNFG_E,R0			
EEERDY_CHECK:
	move.bp		X:(r0),A
	brclr		#0x01,A1,EEERDY_CHECK
	
	// read the data from EEPROM
	move.l		b10,r0		// r0 contains source address of EEPROM
	move.w		x:(r0),a	// r2 contains the destination address of the data
	move.w		a1,x:(r2)
	adda		#1,r2		// source address ++
	inc.l		b			// destination address ++
	dec.w		y0			// length--
	bne			READ_WORD
	
	// pop b,r0
	move.l		x:(sp)-,r0
	move.l		x:(sp)-,b
	move.l		x:(sp)-,b2
	
	rts
}

/***************************************************************************//*!
*
* @brief  Read a word from EEPROM
* 		  
*
* @param  wordAddr: the word address of EEPROM, this is the place where where the data is
*                   fetched from
* 		  data:     a word pointer 
*
* @return  N/A
*		
* @remarks 	Read a word from EEPROM. Beware that the base address starts at 0x1e000
*
****************************************************************************/
asm void EepromReadWord(UWord32 wordAddr,UWord16 *data)
{
	// A is address,R2 is data pointer
	
	// push b,r0
	adda		#2,sp
	move.l		b2,x:(sp)+
	move.l		b10,x:(sp)+
	move.l		r0,X:(sp)
	tfr			a,b
	
	// wait for CCIF bit becoming 1
	move.l		#FTFL_FSTAT_E,R0			
CCIF_CHECK:
	move.bp		X:(r0),A
	brclr		#0x80,A1,CCIF_CHECK
	
	// wait for EEERDY bit becoming 1
	move.l		#FTFL_FCNFG_E,R0			
EEERDY_CHECK:
	move.bp		X:(r0),A
	brclr		#0x01,A1,EEERDY_CHECK
	
	// read the data from eeprom
	move.l		b10,r0
	move.w		x:(r0),A
	move.w		A1,x:(r2)
	
	// pop b,r0
	move.l		x:(sp)-,r0
	move.l		x:(sp)-,b
	move.l		x:(sp)-,b2
	
	rts
}

/***************************************************************************//*!
*
* @brief  Write a long word into EEPROM
* 		  
*
* @param  wordAddr: the word address of EEPROM, this is the place where the data
* 					is written into
* 		  data:     the long word data 
*
* @return N/A
*		
* @remarks 	Write a long word into EEPROM. Beware that the base address starts at 0x1e000, 
*           and it must be an even address
*
****************************************************************************/
asm void EepromWriteLongWord(UWord32 wordAddr,UWord32 data)
{
	// A is address,B is data
	
	// push c,r0
	adda		#2,sp
	move.l		c2,x:(sp)+
	move.l		c10,x:(sp)+
	move.l		r0,X:(sp)
	tfr			a,c
	
	// wait for CCIF bit becoming 1
	move.l		#FTFL_FSTAT_E,R0			
CCIF_CHECK:
	move.bp		X:(r0),A
	brclr		#0x80,A1,CCIF_CHECK
	
	// wait for EEERDY bit becoming 1
	move.l		#FTFL_FCNFG_E,R0			
EEERDY_CHECK:
	move.bp		X:(r0),A
	brclr		#0x01,A1,EEERDY_CHECK
	
	// write the data into eeprom
	move.l		c10,r0
	move.l		b10,x:(r0)
	
	// pop c,r0
	move.l		x:(sp)-,r0
	move.l		x:(sp)-,c
	move.l		x:(sp)-,c2
	
	rts
}

/***************************************************************************//*!
*
* @brief  Write a string of long words into EEPROM
* 		  
*
* @param  wordAddr: the long  word address of EEPROM, this is the start place where 
* 					the data string is written into
* 		  data:     the long word data pointer
* 		  length:   the length of the string in unit of long Word
*
* @return N/A
*		
* @remarks 	Write a string of long words into EEPROM. Beware that the base address 
*           starts at 0x1e000 and it must be an even address
*
****************************************************************************/
asm void EepromWriteLongWordString(UWord32 wordAddr,UWord32* data, UWord16 length)
{
	// A is address,R2 is data pointer,Y0 is the length of the string
	
	// push b,r0
	adda		#2,sp
	move.l		b2,x:(sp)+
	move.l		b10,x:(sp)+
	move.l		r0,X:(sp)
	tfr			a,b

WRITE_LONGWORD:
	// wait for CCIF bit becoming 1
	move.l		#FTFL_FSTAT_E,R0			
CCIF_CHECK:
	move.bp		X:(r0),A
	brclr		#0x80,A1,CCIF_CHECK
	
	// wait for EEERDY bit becoming 1
	move.l		#FTFL_FCNFG_E,R0			
EEERDY_CHECK:
	move.bp		X:(r0),A
	brclr		#0x01,A1,EEERDY_CHECK
	
	// write the data into EEPROM
	move.l		b10,r0		// r0 contains destination address of EEPROM
	move.l		x:(r2),a	// r2 contains the source address of the data
	move.l		a10,x:(r0)
	adda		#2,r2		// source address += 2
	add.l		#2,b		// destination address += 2
	dec.w		y0			// length--
	bne			WRITE_LONGWORD
	
	// pop b,r0
	move.l		x:(sp)-,r0
	move.l		x:(sp)-,b
	move.l		x:(sp)-,b2
	
	rts
}

/***************************************************************************//*!
*
* @brief  Read a string of long words from EEPROM
* 		  
*
* @param  wordAddr: the long word address of EEPROM, this is the start place where 
* 					the data string is read 
* 		  data:     the long word data pointer
* 		  length:   the length of the string in unit of Word
*
* @return N/A
*		
* @remarks 	Read a string of long words from EEPROM. Beware that the base address 
*           starts at 0x1e000 and it must be an even address
*
****************************************************************************/
asm void EepromReadLongWordString(UWord32 wordAddr,UWord32* data, UWord16 length)
{
	// A is address,R2 is data pointer,Y0 is the length of the string
	
	// push b,r0
	adda		#2,sp
	move.l		b2,x:(sp)+
	move.l		b10,x:(sp)+
	move.l		r0,X:(sp)
	tfr			a,b

READ_LONGWORD:
	// wait for CCIF bit becoming 1
	move.l		#FTFL_FSTAT_E,R0			
CCIF_CHECK:
	move.bp		X:(r0),A
	brclr		#0x80,A1,CCIF_CHECK
	
	// wait for EEERDY bit becoming 1
	move.l		#FTFL_FCNFG_E,R0			
EEERDY_CHECK:
	move.bp		X:(r0),A
	brclr		#0x01,A1,EEERDY_CHECK
	
	// read the data from EEPROM
	move.l		b10,r0		// r0 contains source address of EEPROM
	move.l		x:(r0),a	// r2 contains the destination address of the data
	move.l		a10,x:(r2)
	adda		#2,r2		// source address += 2
	add.l		#2,b			// destination address += 2
	dec.w		y0			// length--
	bne			READ_LONGWORD
	
	// pop b,r0
	move.l		x:(sp)-,r0
	move.l		x:(sp)-,b
	move.l		x:(sp)-,b2
	
	rts
}

/***************************************************************************//*!
*
* @brief  Read a long word from EEPROM
* 		  
*
* @param  wordAddr: the long word address of EEPROM, this is the place where where the data is
*                   fetched from
* 		  data:     a long word pointer 
*
* @return  	N/A
*		
* @remarks 	Read a long word from EEPROM. Beware that the base address starts at 0x1e000,
*           and it must be an even address
*
****************************************************************************/
asm void EepromReadLongWord(UWord32 wordAddr,UWord32 *data)
{
	// A is address,R2 is data pointer
	
	// push b,r0
	adda		#2,sp
	move.l		b2,x:(sp)+
	move.l		b10,x:(sp)+
	move.l		r0,X:(sp)
	tfr			a,b
	
	// wait for CCIF bit becoming 1
	move.l		#FTFL_FSTAT_E,R0			
CCIF_CHECK:
	move.bp		X:(r0),A
	brclr		#0x80,A1,CCIF_CHECK
	
	// wait for EEERDY bit becoming 1
	move.l		#FTFL_FCNFG_E,R0			
EEERDY_CHECK:
	move.bp		X:(r0),A
	brclr		#0x01,A1,EEERDY_CHECK
	
	// read the data from eeprom
	move.l		b10,r0
	move.l		x:(r0),A
	move.l		A10,x:(r2)
	
	// pop b,r0
	move.l		x:(sp)-,r0
	move.l		x:(sp)-,b
	move.l		x:(sp)-,b2
	
	rts
}


#endif
